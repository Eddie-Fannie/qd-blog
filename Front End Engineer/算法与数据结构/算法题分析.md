## 1. 两数之和

**给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。** 

> 本人的思路是根据目标值和数组各项的差值，然后循环判断数组哪项和差值相等，再返回数组下标，这样就导致了可能目标值和数组某项差值等于该项自身值等问题。

> 大神思路
>
> - 初始化一个 `map = new Map()`
> - 从第一个元素开始遍历 `nums`
> - 获取目标值与 `nums[i]` 的差值，即 `k = target - nums[i]` ，判断差值在 `map` 中是否存在
>   1. 不存在（ `map.has(k)` 为 `false` ） ，则将 `nums[i]` 加入到 `map` 中（key为`nums[i]`, value为 `i` ，方便查找map中是否存在某值，并可以通过 `get` 方法直接拿到下标）
>   2. 存在（ `map.has(k)` ），返回 `[map.get(k), i]` ，求解结束
> - 遍历结束，则 `nums` 中没有符合条件的两个数，返回 `[]`
>
> ```javascript
> var twoSum = function(nums, target) {
>     let map = new Map()
>     for(let i = 0; i< nums.length; i++) {
>         let k = target-nums[i]
>         if(map.has(k)) {
>             return [map.get(k), i]
>         }
>         map.set(nums[i], i)
>     }
>     return [];
> };  // 时间复杂度O(n)
> ```

> 其他解法
>
> 1. 暴力法
>
>    - 使用两层循环，外层循环计算 当前元素与target之间的差值，内层循环寻找该差值，若找到该差值，则返回两个元素的下标。
>
>    - 时间复杂度： O(n^2)
>
>      ```javascript
>      /**
>      * @param {number[]} nums
>      * @param {number} target
>      * @return {number[]}
>      */
>      var twoSum = function(nums, target) {
>        for(var i = 0; i<nums.length; i++) {
>          var dif = target - nums[i];
>          // j = i+1 的目的是减少重复计算和避免两个元素下标相同
>          for(var j = i+1;j<nums.length;j++) {
>            if(nums[j] == dif)
>              return [i,j]
>          }
>        }
>      }
>      ```

> 2. 利用数组减少查询时间
>
>    - 使用一层循环，每遍历到一个元素就计算该元素与 targettarget 之间的差值 difdif，然后以 difdif 为下标到数组temp中寻找，如果 temp[dif] 有值(即不是 undefinedundefined)，则返回两个元素在数组 numsnums 的下标，如果没有找到，则将当前元素存入数组 temptemp 中(下标: nums[i], Value: inums[i],Value:i) 。
>
>    - 时间复杂度：O(n)
>
>      ```javascript
>      /**
>      * @param {number[]} nums
>      * @param {number} target
>      * @return {number[]}
>      */
>      var twoSum = function(nums, target) {
>        var temp = []
>        for(var i = 0;i<nums.length;i++) {
>          var dir = target - nums[i];
>          if(temp[dif] != undefined){
>            return [temp[dir], i];
>          }
>          temp[nums[i]] = i;
>        }
>      }
>      ```
>
>      

## 17.电话号码的字母组合

**给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。** 

> 例如输入：‘23’
>
> 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].



> 思路：
>
> - 先把电话号码和字母映射建立起来
> - 将输入的数字字符串进行分隔成数组
> - 然后把第二步的数组映射成字母数组，然后循环第一项和第二项，并用一个数组记录保存下来
> - 以防字母数组长度大于2，就利用splice把结果数组前两项用结果数组替代，并和后面的继续递归操作

```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    let wordArray = ['',1,'abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']//显而易见的可以看出数组序列为2-9时分别对应什么字母字符串
    let digitsArray = digits.split('')//把输入的数字字符串转换为一个一个数组，如'23'-> ['2','3']
    let codeArray = []//字母字符串数组
    digitsArray.forEach(item =>{
        //判断输入的字符串有没有1
        if(wordArray[item]) {
            codeArray.push(wordArray[item])
        }
    })
    // 还需要加一个判断, 如果只输入一个数字, 如 "2" 的时候, 只进行一次循环.
  if(codeArray.length === 1) {
    var temp = []
    for(let i = 0; i < code[0].length; i ++) {
      temp.push(codeArray[0][i])
    }
    return temp
  }
    let comb = arr => {
        let resultArray = []
        for(let i = 0,lh=codeArray[0].length;i<lh;i++) {
            for(let j = 0, lh=codeArray[1].length;j<lh;j++) {
                // let result = codeArray[0][i]+codeArray[1][j]
                // resultArray.push(result)
                //等换于
                resultArray.push(`${arr[0][i]}${arr[1][j]}`)
            }
        }
        arr.splice(0,2,resultArray)//把映射完成的数组从第一项开始替换前两项为resultArray
        if(arr.length > 1) {
            comb(arr)
        } else {
            console.log(resultArray)
            return resultArray
        }
        return arr[0]
    }
    return comb(codeArray)
};
letterCombinations("789")
```

